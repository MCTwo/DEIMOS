function recombine_slit,  slit, selected, outfile
;+.
; NAME:
;    slitexam
;
; PURPOSE:
;    sums multiple frames generated by spslit, does CR rejection
;
; CALLING SEQUENCE:
;   slitexam, file, result
; 
; INPUTS:
;    file -- string filename of relevant spSlit*.fits file
; 
; OPTIONAL OUTPUTS:
;    lineparams -- array of structures containing parameters of gauss 
;                   fits to skylines.  Centers, amplitudes, and sigmas
;	
; KEYWORDS:
;    noplot -- if set, skips the ATV plot
;    NLSKY  -- if set, performs a nonlocal sky fit and sky
;              subtraction on slits with <12 sky rows.
;              If NLSKY = 2 or NLSKY = 'all', NLSKY is performed for
;              all slitlets. 
; OUTPUTS:
;   result -- structure containing flux, ivar, and map of pixels
;             rejected in various frames (CR rejected), weighted sum
;             of object-sky.
;   totalexp -- total exposure time of all frames
; 
; COMMENTS:
;  The output structure has the dimensions of the slitlet, with the
;  flux being an invvar weighted average, ivar the sum of the input
;  invvar, mask is as the spslit mask, and crmask = 2^i where i
;  is the frame in which a CR was
;  expunged.
;
; REVISION HISTORY:
;  07jun02 MD
;  24-July-2002 DPF modified to do sky fit AFTER image combine
;  29-July-2002 DPF No... do sky removal before image combine
;----------------------------------------------------------------------



 if n_params() lt 2 then begin
      print, 'CALLING SEQUENCE: outstr = recombine_slit(slit,goodexp,(optional output fits file))'
      retall
  endif

 if n_params() eq 3 then begin
     if size(outfile, /tname) ne 'STRING' then begin
         print, 'Output file name must be a string!'
         retall
     endif
     writefile=1 
 endif else writefile=0

;check if input is file or structure
if size(slit, /tname) eq 'STRING' then begin
  data = mrdfits(slit,1,header)
endif 


  ;make the good data array
  dims=size(data.spflux,/dimension)
  nexp=dims[2];
  ngoodexp= size(selected,/DIMENSIONS)
  ngoodexp=ngoodexp[0]

  if ngoodexp LT 1 then message, 'You must specify at least one good exposure!'

  goodexp=make_array(nexp,/int,value=0)

  for sksub=0, nexp-1 do begin
      for good=0, ngoodexp-1 do begin
         if sksub eq selected(good) then goodexp(sksub)=1
     endfor
  endfor

;try masking edge of slit to account for imperfect extraction
  dims=size(data.spivar,/dimension)
  ydatasize=dims[1]
  for sksub=0, nexp-1 do begin
    data.spivar[*,0,sksub]=0;
    data.spivar[*,1,sksub]=0;
    data.spivar[*,2,sksub]=0;
    data.spivar[*,ydatasize-3,sksub]=0;
    data.spivar[*,ydatasize-2,sksub]=0;
    data.spivar[*,ydatasize-1,sksub]=0;
  endfor


  growfac=max(data.offsets)-min(data.offsets)+1
  dims=size(data.spflux,/dimension)
  xdatasize=dims[0]
  ydatasize=dims[1]
  newdims=[xdatasize,ydatasize+growfac,ngoodexp]
  dims[1]=dims[1]+growfac

  clean_shifted=make_array(newdims,/float,value=0)
  clean_shifted_nosky=make_array(newdims,/float,value=0)
  ivar_shifted=make_array(newdims,/float,value=0)
  pixmask_shifted=make_array(newdims,/float,value=0)

 ;subtract the sky and shift data for dithers
  good=0
  for sksub=0, nexp-1 do begin

    if goodexp(sksub) EQ 1 then begin 
      shiftmin=data.offsets(sksub)
      shiftmax=data.offsets(sksub)+ydatasize-1
      clean_shifted[*,shiftmin:shiftmax,good]=(data.spflux[*,*,sksub]-data.sky)*data.fluxscale[sksub]
      clean_shifted_nosky[*,shiftmin:shiftmax,good]=data.spflux[*,*,sksub]*data.fluxscale[sksub]
      ivar_shifted[*,shiftmin:shiftmax,good]=data.spivar[*,*,sksub]/(data.fluxscale[sksub]*data.fluxscale[sksub])
      pixmask_shifted[*,shiftmin:shiftmax,good]=data.spmask[*,*,sksub]
      good+=1
    endif

  endfor


  final = avsigclip(clean_shifted,ivar_shifted,inmask=pixmask_shifted)
  final_nosky = avsigclip(clean_shifted_nosky,ivar_shifted,inmask=pixmask_shifted)

  newbitmask=make_array(dims[0],dims[1],/byte,value=7b)
  tempmask=make_array(dims[0],dims[1],/byte,value=7b)
  for sksub=0, nexp-1 do begin
    shiftmin=data.offsets(sksub) 
    shiftmax=data.offsets(sksub)+ydatasize-1

    if goodexp(sksub) EQ 1 then begin 
      tempmask[*,shiftmin:shiftmax]=data.spmask[*,*,sksub]
      newbitmask=newbitmask and tempmask
    endif

  endfor

     result =  { flux:floatcompress(final.flux), $
                 rawflux:floatcompress(final_nosky.flux), $
                 ivar:floatcompress(final.ivar), $
                 mask:newbitmask, crmask:byte(final.mask AND 255B), $
                 lambda0:data.lambda0, dlambda: data.dlambda, $
                 lambdax: data.lambdax, tiltx: data.tiltx, $ 
                 slitfn:data.slitfn,  dlam:data.dlam, $
		 infomask: data.infomask, fluxscale: data.fluxscale, $
                 offsets: data.offsets, rawsize: data.rawsize, dithersize: data.dithersize, expseeing: data.expseeing, seeing: data.seeing, $
                 good_frames: selected}

if writefile eq 1 then begin
  mwrfits, result, outfile, /create, /no_comment
endif

return,result

end










