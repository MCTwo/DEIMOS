;+
; NAME:
;   deimos_spslit
;
; PURPOSE:
;   rectify, find wavelength solution, write spSlit files
;
; CALLING SEQUENCE:
;   deimos_spslit, chipno, maskno, calibfile, $
;           badchip, sciencenames, $
;           outdatadir=outdatadir, flat=flat, plot=plot,pixmap=pixmap
;
; INPUTS:
;   chipno       -- which of the 8 chips (1-8)
;   maskno       -- slit mask number (can be string)
;   calibfile    -- calibSlit file to use for flat, arc wavelengths (array)
;   badchip      -- mask of bad chip regions (1=good)
;   sciencenames -- list of file names of science frames
;   outdatadir   -- output directory for spSlit files;
;   pixmap       -- a pixel-to-pixel response correction to be
;                   multiplied by the given data.  1 used if not passed.
;    
; KEYWORDS:
;   flat         -- set to use flatfield in calibSlit file
;   plot         -- set to generate diagnostic plots on screen
;
; OUTPUTS:
;   generates a series of spSlit files, one for each slit
;
; EXAMPLES:
;
; COMMENTS:
;   This routine reads science frames and calibSlit files generated by
;    deimos_mask_calibrate and produces spSlit files, one for each
;    slit. 
;
; REVISION HISTORY:
;
;       Wed Feb 20 17:52:02 2002, Douglas Finkbeiner (dfink)
;             Split off from 2dtest, from 2001-Aug-22
;       2002-Apr-06  MD - transpose so Lambda is first, add comments! 
;       2002-May-17  MD - use plan files for mulitple frames/mask
;       2002-Jun-05  MD&DPF - Major rewrite in Waimea
;       2002-Jun-12  DPF - Major clean-up and re-commenting
;
;----------------------------------------------------------------------

pro deimos_spslit, chipno, maskno, calibfile, $
          badchip, sciencenames, $
          outdatadir=outdatadir, flat=flat, plot=plot, pixmap=pixmap, $
          quick=quick

  readnoise = 2.32
  noisesq = readnoise^2+5.



  maskstr = size(maskno, /tname) EQ 'STRING' ? $
    maskno : string(maskno, format='(I4.4)')

  vprint, 4, 'Reading tables...'
  bfile = findfile(strmid(maskstr,0,4)+'*bintab*.fits*', count=nfiles)
  if nfiles gt 0 then $
    objectcat = deimos_tables(bfile[0], bluslits=slitcoords, $
                            slitobjmap=slitobjmap) $
    else objectcat = deimos_tables(sciencenames[0], bluslits=slitcoords, $
                            slitobjmap=slitobjmap) 

  
  sciheader=headfits(sciencenames[0])
  deimos_grating, sciheader, grating, grangle, lambda_c


  n_exposures =  n_elements(sciencenames) ;how many exposures?
  vprint, 2, 'Beginning loop over slits, with ', n_exposures, $
    ' science frames'
  
  if n_elements(pixmap) eq 0 then begin
     pixmap = 1.
     pixflatgood = 1
  endif else $ 	
    pixflatgood = (pixmap GT 0.8) AND (pixmap LT 1.25)
; just throw away highly deviant pixels in pixflat

    
;-------------------------------------------
; choose the right superdark and read it in
    searchlist=concat_dir(getenv('CALIB_DATA'), $
        'superdark.*'+'g'+strcompress(string(long(grating)),/remove)+'*.gz')
     superdarks=findfile(searchlist)
    
; exclude dec. 19 superdark - only for oct. 11 data
     superdarks=superdarks[where(strpos(superdarks,'2002dec19') lt 0)]
     ndarks=n_elements(superdarks)
     if ndarks eq 0 and quick le 0 then message,'You need a superdark file in CALIB_DATA!  I mean it, buster!'

     if quick le 0 then begin
        superdarkdates=dblarr(ndarks)
        for i=0,ndarks-1 do superdarkdates[i]=juldayfromfilename(superdarks[i])
        mjd = sxpar(sciheader, 'MJD-OBS')
        minseparation=min(abs(superdarkdates-mjd),bestdate)
        if mjd lt 52558.1 OR mjd gt 52558.8 then $
            darkfile=superdarks[bestdate]  $
            else darkfile=concat_dir(getenv('CALIB_DATA'), $
                             'superdark.2002dec19.g1200.fits.gz')
       superdark=mrdfits(darkfile,chipno,/silent) 
       vprint,4, 'Using superdark file ',darkfile
     endif else superdark =  0

;----------------------------------------------------
; Read in the vignetting flat and apply it here, too
        vigflatname = getenv('CALIB_DATA')+'/vignettingflat.fits.gz'

	if file_test(vigflatname) eq 0 and quick le 0 then message,'You need a vignetting flat in CALIB_DATA!  I mean it, buster!'

        cornerchip=(chipno MOD 4) eq 0 OR (chipno MOD 4) eq 1

        if cornerchip AND quick le 0 then begin
            vigflat=mrdfits(vigflatname,chipno,/silent)
            nearlyvig=(badchip AND 4b) eq 4b
            nearlyvig=nearlyvig OR dilate(nearlyvig,intarr(1,101)+1)
            whnear=where(nearlyvig, nearct)
            delvarx, nearlyvig
        endif else vigflat=1.

        if n_elements(vigflat) eq 1 then nearct=0

; empirically, the vignetting in the science frames doesn't quite
; match what we got from dome flats, so:
;        if chipno le 4 then vigpower=0.65 else vigpower=1.0

; WE NEED TO CHECK IF THIS IS DEEP DATA OR NOT HERE!!!!!!!!!!
; look in the bintab file for the project name.
        deimos_isdeep, isdeepdata

   for exposure=0, n_exposures-1 do begin ;loop over exposures



; Read primary header, and science image for one chip
     vprint, 2, ' '
     vprint, 2, 'Science Frame', byte(exposure+1), ': ', sciencenames[exposure]
     sci_header = headfits(sciencenames[exposure])
            
; check date; crosstalk existed before Aug. ~20th.
     mjd = sxpar(sci_header, 'MJD-OBS')
; if date doesn't appear (DCS?), assume we're OK. 

     needsfixing = (mjd lt 52505.) AND mjd gt 1.
            
     specimage = deimos_read_chip(sciencenames[exposure], chipno, $
                                  fixup = needsfixing, quick=quick) 

     if stdev(specimage[0:99999]) eq 0 then begin
         message, $
           'WARNING:  There is no signal in this image!', /info
         print, $
           'WARNING:  There is no signal in this image!'
         return
     endif


; get exp. time in seconds
     exposure_time = float(sxpar(sci_header, 'EXPTIME'))
                                
; get median so as to flag CR's     
     medspec = djs_median(specimage, width=5, boundary='reflect') > 0.01 
            


; use median for invvar unless CR or other anomaly makes it locally high

     if quick le 2 then $
     specivar = ((badchip AND 1b) eq 0b)*((specimage/medspec gt 3.)/$
                         ((specimage > 5.) +readnoise^2) + $
       (specimage/medspec le 3.)/((medspec > 5.)+readnoise^2)) $
     else specivar = ((badchip AND 1b) eq 0b)/(medspec+noisesq)





; apply pixmap 

     ncol = (size(specimage,/dim))[1]

     if quick le 0 then begin
        specimage = specimage*pixmap
        specivar = specivar/pixmap^2*pixflatgood
     endif

; remove the FCS light, as well as dark current, with a 'superdark'.  Use the interslit minima to fit a constant offset from 
; this dark to subtract off as well; the level seems to vary by ~1 count.  
; Note that this all has to be done AFTER the inverse variance is calculated; and that it _may_ fix the chip 5 
; problems (certainly the glow at the top of chip 5 is visible in the superdark).

                                ; Deal with this now by having a
                                ; diversity of superdarks.  Need to
                                ; test the above again for all chips.

     if quick le 0 then begin
	specimage=specimage-superdark*(exposure_time/1200.)

        deimos_findmins,specimage,specivar EQ 0 OR badchip ne 0,planepars,minarr
	wheremin=where(minarr ne -1,minct)

	if minct gt 0 then extraoffset=median(minarr[wheremin],/even) else extraoffset=0.
	if minct eq 0 then vprint,2, 'NO GOOD MINIMA FOUND!'
        specimage=specimage-extraoffset
     endif


     if chipno EQ 5 then begin 
        med = median(specimage[*, 4000:4040])
        vprint, 3, 'Chip 5 -- fixing up image top with median ', med
        for i=4020, 4095 do specimage[*, i] = specimage[*, i]-median(specimage[*, i])+med
        specimage[*, 4090:4095] = med
        specivar[*, 4090:4095] = 0
     endif 

; apply vignetting flat - we are assuming that the scattered light
;                         does not need any (further) vignettign correction
     if quick le 0 then begin 
        specimage = specimage/(vigflat)
        specivar = specivar*(vigflat^(2))

; assume vignetting correction is correct to 10% where we are
; vignetted or near the vignetted region
          if cornerchip AND nearct gt 0 then specivar[whnear]=1./(1/specivar[whnear]+0.1^2*(specimage[whnear])^2)
      endif


; find global offset (per chip) due to flexure
     vprint, 4, 'Reading calib files - first pass...'
     nslitlets = n_elements(calibfile)
     xpos1 = fltarr(ncol, nslitlets)
     xpos2 = fltarr(ncol, nslitlets)
     for islit=0, nslitlets-1 do begin
        vprint, 2, string(islit, format='($,I3.2)')
        calib = mrdfits(calibfile[islit], 1, header, /silent)
        
        xpos1[*, islit] = calib.x0
        xpos2[*, islit] = calib.x1
     endfor 
     vprint, 4, " "
     length=abs(xpos2-xpos1)
     dx = deimos_edge_offset(xpos1, xpos2, ypos1, ypos2, specimage, $
                             specivar*((badchip AND 3b) EQ 0), $
                             longslits=(median(length) gt 200))

; -------- Begin loop over slitlets
     vprint, 4, 'beginning loop over ', byte(nslitlets), ' slitlets'
     for islit=0, nslitlets-1 do begin ;loop over all slitlets
         
       
        calib = mrdfits(calibfile[islit], 1, header, /silent)
        if quick le 0 then $
          varslitfn=mrdfits(calibfile[islit], 2, /silent,status=status) $
        else status = -1

; if variable slit function not available, use the ordinary one
        if status lt 0 then begin
		varslitfn=calib.slitfn
        	if quick le 0 then $
                  message,'no varslitfn found in '+calibfile[islit],/inform
	endif else begin
		ndimvar=(size(varslitfn))[0]
		if ndimvar gt 1 then $
                  nrowsvar=(size(varslitfn,/dim))[1] else nrowsvar=0
		if nrowsvar ne n_elements(calib.slitfn) then begin
			varslitfn=calib.slitfn
			if quick le 0 then $
                message,'invalid varslitfn found in '+calibfile[islit],/inform
		endif
	endelse

        slitn = sxpar(header, 'SLITNO')
        objid = sxpar(header,'OBJID')
        if isdeepdata then issn=   (long(objid)/long(1D7) eq 6) $
		else issn = 0

        slitwid = sxpar(header, 'SLITWID')
; get the maskpa and slitpa from the calibSlit header.
        slitpa = sxpar(header, 'SLITPA')
        maskpa = sxpar(header, 'MASKPA')
        wavesig = sxpar(header, 'WAVESIG')
        tstart = systime(1) 
        x0 = calib.x0 +dx
        x1 = calib.x1 +dx


        interp = quick le 0

; rectify spec and specivar; specmask is zero if ANY pixel
;  contributing to the rectified image was bad (with /interp or not)

        rect_spec = deimos_rectify_slit(specimage, specivar, x0, x1, $
                                        interp=interp,  npad=0, mask=specmask)

        rect_med = deimos_rectify_slit(medspec, specivar, x0, x1, $
                                       interp=interp, npad=0, mask=medmask)

        if quick le 0 then $
          interp_mask = deimos_rectify_slit(float((badchip AND 1B) EQ 1B), $
                specivar*0+1., x0, x1, interp=interp, npad=0) NE 0 $
          else interp_mask = 0

        nearvig_mask = deimos_rectify_slit(float((badchip AND 4B) EQ 4B), $
                     specivar*0+1., x0, x1, interp=interp, npad=0) NE 0

        if quick le 0 then $
          vig_mask = deimos_rectify_slit(float((badchip AND 2B) EQ 2B), $
                  specivar*0+1., x0, x1, interp=interp, npad=0) NE 0 $
           else vig_mask = nearvig_mask

        

	if quick le 0 then $
          pix_mask = deimos_rectify_slit(float(pixflatgood eq 0b), $
               specivar*0+1., x0, x1, interp=interp, npad=0) NE 0 $
          else pix_mask = 0

; remove this?
;        rect_spec = rect_spec*specmask
;        rect_spec = rect_spec*(vig_mask eq 0)

        rect_specivar = deimos_rectify_slit(specivar, specivar, $
                                            x0, x1, interp=interp, npad=0)

        rect_specivar = rect_specivar*specmask ;*( missedbadpix eq 0)
;
; normalize signal to 3600. sec exposure
        rect_spec = rect_spec*(3600./exposure_time)
        rect_med =  rect_med*(3600./exposure_time)
        rect_specivar = rect_specivar*(exposure_time/3600.)^2 
;keep s/n constant
 
        sizey = (size(rect_spec, /dimens))[1]
        ncol  = (size(rect_spec, /dimens))[0]

; Apply flat --- NB: the flat is for the WRONG position!!! FIX this!!!
; Changed to 2d slit function!
;        if keyword_set(flat) AND sizey lt 400 then begin 
        if keyword_set(flat)  then begin 
           rect_spec = deimos_applyflat(rect_spec, calib.flat, $
              varslitfn, invvar=rect_specivar, quick=quick)

        endif

; wavelength from arcs in calibSlit file (from deimos_fit_wavelength)
; we should use this as a guess and tweak to sky lines !!!

        wave = lambda_eval(calib,/double) ;extract lambda from structure

; -------- Sky model (trivial for the moment)

;TBD: move all sky modeling to 2nd stage of processing-----     
 
               
        yobj = objpos_on_slit(slitcoords, slitobjmap, slitn, $
                              nrow=sizey, nobj=nobj)
	offslit = yobj LT 0 OR yobj GT (sizey-1)
        skyok = bytarr(sizey)


	edge=5+2*(grating lt 601)

        skyok[edge:sizey-edge-1] = 1B
        ; remove rows near objects (within wid pixels)
        wid = 14
        
        if nobj eq 0 then vprint, 4, 'DEIMOS_SPSLIT:   Sky only slit?'


          isastar = 0
	  isaskyslit=0

        if isdeepdata then begin
          whichslit = where(slitcoords.slitno eq slitn, okct)
          if okct gt 0 then whichdes = where(slitobjmap.dslitid $
                          eq slitcoords[whichslit].dslitid, okct)
          if okct gt 0 then whichobj = where(objectcat.objectid $
                          eq slitobjmap[whichdes].objectid, okct)
          if okct gt 0 and (total(whichobj) ge 0) then isaskyslit = $
            strmid(objectcat[max(whichobj)].object, 2, 1) eq '5' 
        endif 

        if NOT isaskyslit then for k=0, nobj-1 do $
          IF NOT(offslit[k]) THEN skyok[(yobj[k]-wid/2) >0: $
                                        (yobj[k]+wid/2) < (sizey-1)] = 0B


        isdata=specmask[100,*] eq 1 OR specmask[ncol-101,*] eq 1
        isdata=isdata AND (calib.slitfn gt 0.95) AND (vig_mask[ncol/2,*] eq 0)

; do not use extra-bright regions on slit for sky

        medprof=skyok*0.
        for i=0,sizey-1 do medprof[i]=median(rect_spec[*,i])
        if total(isdata) gt 10 then $
          skyhigh=medprof-median(medprof[where(isdata)],/even) gt 15. $
        else skyhigh = 0


        skyind = where(skyok AND isdata AND (skyhigh eq 0), ct)


        while (ct lt 7 AND wid gt 2) DO BEGIN 
	      wid=wid-1 
	      skyok[floor(1+wid/4.)>(edge-1) : $
                    ceil(sizey-1-wid/4.)<(sizey-edge)] = 1B 
	      for k=0, nobj-1 do skyok[(yobj[k]-wid/2) > 0: $
                        (yobj[k]+wid/2) < (sizey-1)] = 0B &$
	      skyind = where(skyok AND isdata, ct) 
	      if wid lt 10 then vprint, 2, $
  	        'Warning: < 10 pix around object excluded on slit ',slitn 
	ENDWHILE   

	if ct lt 5 then begin
            isdata=specmask[100,*] eq 1 OR specmask[ncol-101,*] eq 1
            isdata=isdata AND (calib.slitfn gt 0.85) AND (vig_mask[ncol/2,*] eq 0)

	     skyok[edge:sizey-edge-1] = 1B
	     skyind = where(skyok AND isdata, ct)
	     vprint,2, 'no good sky region-using whole slit ',slitn
	endif

        if ct lt 5 then begin
             skyok[(edge-1)>0:(sizey-edge)<(sizey-1)] = 1B
             skyind = where(skyok AND isdata, ct)
             vprint,2, 'no good sky region-using even more of slit ',slitn
        endif

	if ct lt 5 then begin
	 	 vprint,2, 'no sky region on slit ',slitn
		 vprint,2, 'bspline will be very poor'
		skyind=where(skyok,ct)
	endif

	if n_elements(skyind) NE total (skyok) $
          AND total(skyind) ge 0 then begin
            skyok = skyok*0B
            skyok[skyind] = 1B
        endif


        tags = tag_names(calib)
        coeffexists = total(tags eq 'COEFF')
        polyflag = coeffexists eq 0
; compress to save space!
; mark vignetted pixels bad only after we determined the bspline
        
;        rect_spec = floatcompress(rect_spec, ndig=12)
;        rect_specivar = floatcompress(rect_specivar, ndig=8)


; Bitmask definition
;  Bit 0  - flatmask   pixel not flatfielded
;      1  - badpix     bad column, CTE issue, etc.
;      2  - specmask   no data went into this pixel (when rectified)
;      3  - vigpix     vignetted pixel
;      4  - pixmap     bad pixel in the pixmap (e.g. on deep dust grain)
  
;        bitmask = (1B-byte(calib.mask)) + (interp_mask OR missedbadpix)*2B $

        bitmask = (1B-byte(calib.mask)) + (interp_mask)*2B $
          + (1B-specmask)*4B +(vig_mask)*8B +(pix_mask)*16B
  

        if polyflag then begin
           spSlit = {flux: rect_spec, $ ;floatcompress(rect_spec+0., ndig=12), $
                  ivar: rect_specivar, $ ;floatcompress(rect_specivar*(calib.mask ne 0), $
 ;                                     ndig=8), $
                  lambdax:calib.lambdax, tiltx:calib.tiltx, $
                  mask: bitmask, $
                  slitfn: calib.slitfn, $
                  skyrow: skyok, $
;                  skyind: skyind, $
                  slitwidth: slitwid, $
                  dlam:calib.dlam, $
                 infomask: nearvig_mask }
        endif else begin
           spSlit = {flux: rect_spec, $ ;floatcompress(rect_spec+0., ndig=12), $
                  ivar: rect_specivar, $ ;floatcompress(rect_specivar*(calib.mask ne 0), $
;                                      ndig=8), $
                  func: calib.func, xmin: calib.xmin, xmax: calib.xmax, $
                  coeff: calib.coeff, $
                  mask: bitmask, $
                  slitfn: calib.slitfn, $
                  skyrow: skyok, $
;                  skyind: skyind, $
                  slitwidth: slitwid, $
                  dlam:calib.dlam, $
                  infomask: nearvig_mask}
        endelse

 
;       tweak wavelengths of spslit

        if quick le 0 then begin
           deimos_skytweak, spslit, skytweak=skytweak
           wave = lambda_eval(spslit,/double)

; do we want to do this for non-DEEP2 data?
; could add an isdeepdata check
	   if min(spslit.slitfn) ne max(spslit.slitfn) $
	     AND n_elements(spslit.slitfn) gt 15 then $
             spslit=deimos_fixslitends(spslit,varslitfn,leftshift,rightshift,edge=7+2*(grating lt 601))
        endif   


        flag_cr, spslit, flagivar,crmask, medflux=rect_med


        if quick gt 0 then $
           spslit.flux = spslit.flux*(1b-crmask)+rect_med*crmask      



; if quick >1, want to be really quick
        if quick lt 2 OR issn then begin

; deweight vignetted pixels - 100x, say?
           flagivar=flagivar/(1.+99.*vig_mask)

; if this is a sky slit, correct its profile in the spatial direction 
;  to be flat

           if isaskyslit then begin
            
              weight=flagivar*((spslit.mask eq 0B) AND (nearvig_mask eq 0B))
              badcols=total( (spslit.mask AND 22b) ne 0,2) gt 2
              if total(badcols) gt 0 and total(badcols) lt ncol then $
                weight[where(badcols),*]=0.
              profile=total(rect_spec*weight,1) / $
                total(weight,1)
              profile=profile/median(profile)
              correction=(fltarr(ncol)+1.) # profile
              rect_spec=rect_spec/correction
              spslit.flux=rect_spec
              flagivar=flagivar*correction^2
              spslit.ivar=spslit.ivar*correction^2
           endif


; if we have lots of sky, try to subtract off gradients
           if n_elements(skyind) gt 100 then begin
               vprint,2,'attempting to correct gradients in sky'
               skyprof=find_object(spslit,profivar=profivar,/NOSUB)
               xdata=findgen(n_elements(skyprof))
               aa= dblarr(2,n_elements(xdata))
               aa[0,*]=1.D0 
               aa[1,*]=xdata

               skyct=0
               skyok=xdata*0
               skyok[skyind]=1
               skyok=erode(skyok,fltarr(15)+1)
               if total(skyok) gt 60 then skyind=where(skyok,skyct)
               hogg_iter_linfit,aa[*,skyind],skyprof[skyind],profivar[skyind],fit
               synth=fit[0]+fit[1]*xdata
               if abs(fit[1]*n_elements(xdata)) gt 0.3 and  $
                        abs(fit[1]*n_elements(xdata)) lt 20 $
                         AND min(synth) gt 0 AND skyct gt 60 $
                 then begin
                   vprint,2,'modifying gradients'
                   
                   synth=synth-mean(synth)
                   synth2=(fltarr(ncol)+1) # synth
                   spslit.flux=spslit.flux-synth2
                   rect_spec=spslit.flux
                   vprint,2,'parameters: '+string(fit)
               endif
            
           endif



           skywave = wave[*, skyind]
           skyflux = rect_spec[*,skyind]
           whcr=where(crmask[*,skyind] ne 0,crct)

; trying to keep bspline from going crazy at the ends by giving these
; masked pixels nonzero weight
           skyivar = (flagivar*((spslit.mask AND 22b) eq 0))[*, skyind]
           skyx=lindgen(ncol,n_elements(skyind)) MOD ncol
           badsky=(skyivar eq 0.)
           whok=where(badsky eq 0b,okct)
           if okct gt 0 then begin
              meanivar=mean(skyivar[whok])
              whbad=where((badsky AND (skyx lt EDGE+1 OR skyx gt (ncol-edge-2))) ,badct)
              if badct gt 0 then skyivar[whbad]=meanivar/250.
           endif
; but still want to be careful about CR's!!!
           if crct gt 0 then skyivar[whcr]=0.


; back to original
           everyn = 2.*n_elements(skyind)/3.
           bkspace = (max(skywave)-min(skywave))/(1.5*ncol)
           testrange=wave[ncol/2,*]
           testrange=testrange[sort(testrange)]
 ; determine range of wavelengths in a given column
           deltalambda=abs(testrange[fix(0.9*sizey)]-testrange[fix(0.1*sizey)])

           nbkpts = 1.5*ncol      
           outmask1=1
           outmask2=1

; do this because bspline_iterfit is BROKEN and requires sorting
           ind = sort(skywave)

; Experimenting 12/17/02 - specify breakpoints to happen at set places
;  amongst the sky rows

; only do this if we are very poorly sampled

           if deltalambda lt 0.5*bkspace then begin
              vprint,2, 'doing fixed breakpoints for slit ',slitn
              vprint,2, 'deltalambda: ',deltalambda,'  bkspace: ',bkspace
              nsky=n_elements(skyind)

              if max(offslit) eq 0 then row = floor(mean(yobj)) $
                 else row = sizey/2
              
              if row lt min(skyind) OR row gt max(skyind) $
                then row = median(skyind)

              vprint, 2, 'setting breakpoints to match row ', row

              breakpoints = (wave[0:ncol-1, row:row+1])
              breakpoints=total(breakpoints,2)/2.
	
;          print, 'repeating bspline - slit was too vertical!'
              sset = bspline_iterfit(skywave[ind], skyflux[ind], $
                   invvar=skyivar[ind], upper=20, lower=20, $ 
                   maxiter=3, fullbkpt = breakpoints, $
                   outmask=outmask2, /silent)
              outmask1 = outmask2

           endif else begin
; the old way:
             sset = bspline_iterfit(skywave[ind], skyflux[ind], $
               invvar=skyivar[ind], upper=20, lower=20, $ 
               maxiter=3, everyn=everyn, $
               outmask=outmask1, /silent)
           endelse

; On very vertical slits, the bspline can become degenerate and fail.
; In that case, use the wavelengths on the object for breakpoints.
           if size(sset, /tname) eq 'STRUCT' then begin
            coeffrange = minmax(sset.coeff) 
             if abs(coeffrange[0]) lt 1. and $
                  abs(coeffrange[1]) lt 1. then begin
              if max(offslit) eq 0 then row = mean(yobj) else row = sizey/2
              vprint, 2, 'setting breakpoints to match row ', row
              breakpoints = reform(wave[0:ncol-1, row])
              vprint, 2, 'repeating bspline - slit was too vertical!'
              sset = bspline_iterfit(skywave[ind], skyflux[ind], $
                 invvar=skyivar[ind], upper=20, lower=20, $ 
                       maxiter=3, fullbkpt = breakpoints, $
                       outmask=outmask2, /silent)
              outmask1 = outmask2
             endif
          endif


    
; ADD WAVMASK TO THE BITMASK????????
          outmask = byte(skywave*0b)
          outmask[ind] = outmask1
          wavmask = byte(wave*0b)
          wavmask[*, skyind] = 1B - outmask

       endif   

       if n_elements(wavmask) eq 0 then wavmask = 0

; infomask definition
;  Bit 0  - nearvigmask pixels that are >0% vignetted
;      1  - bsplinemask   pixels rejected in bspline process
;      2  - nobsplinemask pixels for which bspline is undefined (set
;           in slitexam)
;      3  - crmask        pixels identified as having cosmic rays by
;           flag_cr
;      4  - noskytweak    skytweak not applied (set in spslit_combine)
        spslit.infomask = nearvig_mask+wavmask*2B+crmask*8b

; only mask vignetted regions after we've calculated the bspline
; --- OR maybe only at the slitexam stage, I'm leaving it alone for now
; IF for v1_0 we mask the red side differently than blue, here is
; where we'll do it.

;        spslit.flux=spslit.flux*(vig_mask eq 0b)
;        spslit.ivar=spslit.ivar*(vig_mask eq 0b)
      
      if quick le 0 then begin
         spSlit.flux = floatcompress(spslit.flux, ndig=12)
         spslit.ivar= floatcompress(spslit.ivar*(calib.mask ne 0), $
                                      ndig=8)
      endif

; make new FITS header with selected keywords 
        keylist = ['FRAMENO', 'OUTFILE', 'EXPTIME', 'DARKTIME', 'OBSERVER', $
            'OBJECT', 'OBSTYPE', 'ROTATVAL', 'DATE-OBS', 'UT', 'AIRMASS', $
            'TARGNAME', 'EQUINOX', 'DEC',  'RA', 'AZ', 'EL', 'HA', $ 
            'ST', 'UTC', 'MJD-OBS', 'PARANG',  'SYNOPSIS', 'DWFILNAM', $
            'SLMSKNAM', 'GRATEPOS', 'HPLOGTIM']
        hdr = copy_keywords(sci_header, keylist, 'spSlit')
        vers = spec2d_version() ;get version of code
        sxaddpar, hdr, 'SP2DVERS', vers, 'Version of spec2d'
        sxaddpar, hdr, 'AUTHOR', 'Finkbeiner & Davis'
        sxaddpar, hdr, 'CHIPNO', chipno, 'chip number for this slitlet'
        sxaddpar, hdr, 'SLITNO', slitn, 'slit number'
        sxaddpar, hdr, 'SLITX0', calib.x0[2048], 'center of trace'
        sxaddpar, hdr, 'SLITX1', calib.x1[2048], 'center of trace'
        sxaddpar, hdr, 'DX', dx, 'offset from calibslit trace'
        sxaddpar, hdr, 'WAVESIG', wavesig, $
           'RMS error in lambda solution, in AA (1&10 are flags)'                                                     

        if n_elements(leftshift) eq 0 then leftshift = 0.
        if n_elements(rightshift) eq 0 then rightshift = 0.

        if quick le 0 then begin
           sxaddpar, hdr, 'SHIFT0', leftshift, 'shift to fix low-x slit end'
           sxaddpar, hdr, 'SHIFT1', rightshift, 'shift to fix high-x slit end'
           sxaddpar, hdr, 'SKYSIGMA', skytweak.medsigma, $
          'Gaussian sigma of skylines (AA)'
        endif
        sxaddpar, hdr, 'COMMENT', 'FLUX array in units of counts/hour'

; add the slitpa and maskpa to the spSlit hdr.
;        if isdeepdata then 
        sxaddpar, hdr, 'SLITPA', slitpa, 'Slit PA on sky'
;        if isdeepdata then 
        sxaddpar, hdr, 'MASKPA', maskpa, 'Mask PA on sky'
      
        if polyflag then $
          sxaddpar, hdr,'WAVETYPE','POLYFLAG','wavelength solution method' $
        else sxaddpar, hdr,'WAVETYPE','TRACESET','wavelength solution method'

        slitstr = string(slitn, format='(I3.3)')
      
        color = (chipno gt 4) ? 'R':'B' ;red or blue side??

        if quick le 0 OR issn then $
          fname = outdatadir+'spSlit.'+maskstr+'.'+slitstr+color+'.fits' $
        else $
          fname = outdatadir+'quickSlit.'+maskstr+'.'+slitstr+color+'.fits'

        hdr2 = hdr
; Write spSlit file; use /create if exposure eq 0. 
        if quick le 0 then create = exposure eq 0 $
          else create = file_test(fname) eq 0
        mwrfits, spSlit, fname, hdr, create=create
        sxaddpar, hdr2, 'EXTNAME', 'sset', 'B-spline structure'
        if quick lt 2 OR issn then $
           mwrfits, sset, fname, hdr2 ;save bspline structure in separate HDU
      
        timestr = string('Chp', chipno, ' Exp', exposure+1, ' of', $
                         n_exposures, ', slit', slitn, '   Time:', $
                         systime(1)-tstart, ' s   ', fname, ' written', $
                         format='(3(A,I2),A,I4,A,F6.2,A,A,A)')
        vprint, 3, timestr

     endfor                     ;end loop on slitlets
  endfor                        ;end loop on exposures

  return  
end









